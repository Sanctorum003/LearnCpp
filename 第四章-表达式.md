# 基础
## 基础概念






* 运算符重载
    - 可以指定云端对象的类型和返回值的类型
    - 运算对象的个数、运算符的优先级和结合律都是无法改变的

* 左值和右值
    - 辣鸡的C++ PRIMER解释
        -  左值(lvalue) : 是那些求值结果为对象或者函数的表达式，一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象。
        -  右值(rvalue) : 是指一种表达式,其结果是值而非值所在的位置。 
    - 参考博客:https://blog.csdn.net/xuwqiang1994/article/details/79924310
        - 左值(lvalue) : lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。
        - 右值(rvalue) : rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是不在内存中占有确定位置的表达式。
    - 参考博客:https://blog.csdn.net/qq_24964575/article/details/52202989
        - 左值可以当作右值使用,右值不能当左值用.
        - 左值可以出现在=的任何一方,
        - 出现在=右方的左值,是把左值当作右值使用,这是非常正常的.
        - 右值,不能当作左值使用.
        - 能够(单独)出现在=左方的是左值(实际是左右值,左值总是可以当作右值使用)
        - 只能够出现在=右方的,是右值(纯粹的右值),不能当作左值使用.
        - 左值代表地址单元,右值代表数据本身.
        - 地址单元里的数据,是左值变量的右值的含义.
        - 右值包括,纯数据,比如常数100,字符串常量”12345”等
        - 以及地址单元中存储的数据.比如x ,这是左值当作右值使用代表的意义.
        - 以及一些常变量(有确切地址的常量,可以象变量一样有个名字,其实就是变量,只是右值化了,不能当左值使用了)的含义.
        - 左值代表存储器的一个单元.
        - 这是一个物理概念,不仅仅是个地址(地址不过是个编号,是个数值而已),是个实实在在的东西.
        - 右值代表数据,一个数值而已.
    - 参考博客:https://www.zhihu.com/question/382300648
        - 取地址符取到的是一个地址，没有实际存储在哪，所以是右值
        - 如果是寄存器变量也没有地址，所以是右值

> 使用decltype时,左值返回引用类型，右值不返回引用类型。

## 求值顺序
* 只有四种运算符规定了运算顺序，其他都是未定义的
    -  &&
    -  ||
    -  ?:
    -  ,

```cpp
//结果未定义
int i = 0;
cout<<i<<""<<++i<<endl;
```

* 建议如何处理复合表达式
    - 拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求。
    - 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
        - 列外：当改变运算对象的子表达式本身就是另一个子表达式的运算对象时,上述规则无效。
        - 上面这句鬼话看不懂原文： the subexpression that changes the operand is itself the operand of another subexpression. 
        - 一个子表达式改变了操作数，而这个整体又是另一个字表达式的操作数
        - 例子: *++iter

# 算术运算符
* %
    - c++11中向0取整，（去1法）
    - m % n 结果符号跟m相同

# 赋值运算符
* c++11 新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。
> 使用大括号进行列表初始化且初始值存在丢失信息的风险，则编译器将报错

* 复合运算符(e.g. a += b) 值计算一次。而普通运算符(e.g. a = a + b)会进行两次计算

# 递增和递减运算符
* 前置++的返回值为左值，后置++将原始值的副本作为右值返回

* 注意运算对象可以按任意顺序求值
  
```cpp
while(beg !=s.end() && !isspace(*beg))
{
    *beg = toupper(*beg++);//这个是未定义的
}
//要明确后置++的操作是先对自身自加，然后返回的是原始值的右值副本。
//所以这里左侧beg和右侧beg哪一个先执行未定义
```

# 位运算符
* 位运算符只建议用于无符号整数，带符号整数运算未定义

# 类型转换
## 显示转换
*  c++风格

> cast-name<type>(expression)

> cast-name 可以是static_cast,dynamic_cast,const_cast,reinterpret_cast.

> dynamic_cast见19.2

### static_cast
* 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_const

```cpp
double slope = static_cast<double>(j)/i;

void* p = &d;
double *dp = static_cast<double*>(p);
```

### const_cast
* const_cast只能改变运算对象的底层const
* 对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。
只有const_cast能改变表达式的常量属型，使用其他形式的命名强制类型转换改变表达式的常量属型都将引发编译错误。同样的，也不能用const_cast改变表达式的类型

```cpp
const char *pc;
char *p=const_cast<char*>(pc); //正确，但是通过p写值是未定义的行为
```

### reinterpret_cast
* 自己还是个菜鸡，这个就不用了